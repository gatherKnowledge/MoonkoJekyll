---
layout: post
title: 알고리즘 - 03.탐색
categories: [Algorithm]
tags: [Searc, 탐색]
fullview: true
comments: true
published: false
---
##### 순차탐색
> 하나하나 찾으려고하는 값과 비교해서 찾는 탐색 방법
> 시간복잡도 `O(n)`


##### 이진탐색
> 정렬된 배열모양의 구조에서 크기 비교를 통해 값을 찾아내는 방법
> 시간복잡도 `O(logn)`
> 탐색에는 적당한 속도를 보이지만 `삽입과 삭제`에 효율이 매우 떨어진다
>   * 적당한 크기(10)의 배열 `Array[10]`이 있고 0번에 데이터를 삽입한다고 생각해보자
>   * 하나를 삽입하기 위해 기존 Array[0] --> Array[1],Array[1] --> Array[2],Array[2] --> Array[3] ..  Array[9] --> Array[10] 작업이 일어난 후에서야 Array[0]에 새로운 값을 집어 넣을 수 있을 것 이다.

> * 삭제의 경우도 마찬가지이다.
>> LinkedList를 사용하면 될 것이라고 생각 할 수도 있겠다. 하지만 LinkedList의 경우는 저장 된 장소가 연속적이지 않고 단순히 **이전 노드가 다음 노드에 대한 주소값을 갖고 있다는 것** 을 생각해야 한다. 애초에 얘기하고 있는 탐색에 대한 비교대상이 되지 않는다.

##### 이진탐색트리
> 삽입과 삭제에 대한 문제로 인해 고안된 트리구조
> 탐색 시간 복잡도 `O(logn)`

##### 2-3-4트리
> 이진탐색트리의 한쪽으로 쏠리거나 지그재그로 데이터가 정렬된 경우 제대로 된 성능을 낼 수 없기 때문에 고안된 트리구조

###### 최악의 성능을 내는 데이터 입력  모양

```
  / \
 /   \
/     \
```
```
\/
/\
\/
/\
```

##### 흑적 트리
> 234트리는 개념적으로는 간단하지만 구현 시에는 상당히 복잡한 로직이 완성된다 그리고 그 복잡한 로직은 성능저하를 일으킬 수 있기 때문에 고안된 트리구조.
> 234트리와 흑적트리는 1대1로 매칭이 가능하다.
>
