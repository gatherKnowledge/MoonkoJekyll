---
layout: post
title: 프로그래밍 언어론 003
categories: [프로그래밍 언어론]
tags: [구문론, 의미론]
fullview: true
comments: true
published: true
---
### 컴파일러가 소스를 해석하는 방법
1. 문자단위로 분리 후 최소한의 의미있는 문자들의 단위 인  `어휘`로  구성
2. 어휘들을 기준으로 `구문`(문자을 만드는 규칙)을 판단, 특정 어휘 뒤에 나올 수 있는 어휘의 범위들을 만드는 것이라 할 수 있음

>예)컴퓨터는 참 멋져요
>
 * 문자단위 구분 : 컴/퓨/터/는/  /참..
>
 * 어휘단위 구분 : 컴퓨터/는/참/멋지다/!/
이것을 동일하게 프로그래밍 언어에서 볼 수 있다.

=>**컴퓨터 언어에서의 해석도 동일한 과정을 거친다**

 주로 알파벳을 프로그램 문자로 구성되는데, 이런 알파벳은 사람의 입장에서 보는 것일뿐 컴퓨터 입장에서는 하나의 ASCII로 보일 수 밖에없다.
 * `어휘` : 프로그래밍 언어에서의 단위이며 `tokken`이라는 표현으로 쓰기도 한다.

* 언어(자연어)에서의 규칙을 문법이라고 하듯이, 프로그래밍언어에서의 `구문`이다.

언어 구성자라는 것 하나 이상의 언어구성자를 통해서, 프로그램의 언어 일부 구조
if문 같은 경우 if 나오면 그 뒤에는 괄호 열고,  안에는 숫자 값이 들어간다던가, 그리고 else가 들어가는 등의 일련의 과정들

* `식별자` : 토큰 자체보다 광범위한 토큰. `예약어`,  `미리 정의 된 식별자` 등. 그 중에서 특히  재정의를 할 수 없는 식별자들의 경우에는 프로그램의 가독성을 향상시킬 수 있고, 컴파일에 대한 시간을 단축시킬 수 있다. 프로그램 오류 역시 쉽게 찾을 수 있다. 하지만 반대로 너무 많은 식별자가 있다고하면 예약어 자체의 관리가 힘들어지고 중복되는 식별자 때문에, 실제 사용자가 활용할 수 있는 토큰들이 제한된다.

### 프로그래밍 언어에서의 구문 확인
1. BNF(backers normal form)

 컴퓨터 언어에서 언어의 문법을 수학적인 수식으로 나타낼 때 사용하는 언어 도구로 구문에 대한 형식정의를 하는 방법 중 하나이다.
```
표기법
대상(왼쪽) ::= 정의하는 것(오른쪽)
예)
    id ::= id | number
    number ::= 1|2|3|4|5
```
* 비단말기호`<>` : 재정의되어야 하는 요소, 꺾쇠 표기
* 단말기호 : 가장 끝단에 있는 기호.  알파벳, 숫자, 예약어가 단말기호로 사용된다.
* 등호기호`::=` : 정의 관계 메타기호, 왼쪽은 오른쪽으로 정의가 된다, `|`와 같이 사용되어 어떤 식별자로 정의 할 것인지 선택하게 된다.

BNF에 대해 좀 더 이야기 해보자면,  배커스-나우어 형식(Backus Normal Form or Backus–Naur Form) 의 약어로, 1959년 파리에서 개최된 유네스코 학술회의에서 존 배커스(John Backus)가 ALGOL 58에 대한 논문을 발표하였고, 1년 후에 피터 나우어(Peter Naur)가 그 내용을 보완하여 `ALGOL 60`을 기술하여 지금의 형태로 만들었습니다.

이것이 중요한 이유는 프로그래밍 언어의 구문을 기술하는 데 매우 자연스러운 표기법으로, C, Java, PHP 등을 포함한 `대부분의 프로그래밍 언어`의 정의에 가장 널리 사용되기 때문입니다.

언어의 문장들은 BNF의 규칙을 적용해가며 생성되는데, 시작 기호(start symbol)라 불리는 비단말 기호에서 시작되며, 이러한 문장 생성 과정을 `유도`(derivation) 라 합니다.
```
유도과정의 예)
<number> → <number><digit>    ────── ➀
                  | <digit>               ────── ➁
<digit> → 0 | 1 | 2 | … | 9            ────── ➂

이러한 수에 대한 문법이 있다면, 123 을 다음과 같이 유도할 수 있습니다.

<number> ⇒ <number><digit>                 ─ ➀ 에 의해 <number>를 <number><digit>로 대치
                 ⇒ <number><digit><digit>     ─ ➀ 에 의해 <number>를 <number><digit>로 대치
                 ⇒ <digit><digit><digit>         ─ ➁ 에 의해 <number>를 <digit>로 대치
                 ⇒ 1<digit><digit>                ─ ➂ 에 의해 <digit>를 수 1로 대치합니다.
                 ⇒ 12<digit>                        ─ ➂ 에 의해 <digit>를 수 2로 대치합니다.
                 ⇒ 123                               ─ ➂ 에 의해 <digit>를 수 3으로 대치합니다.

여기에서 시작 기호는 <number> 이며, ⇒ 는 '유도 한다'고 읽습니다.
```

`EBNF`가 있는데, 이름에서 알 수 있다시피, BNF의 업그레이드 버전이다. 기존의 비효율적인 표기에 대해 더 읽기 쉽고, 사용하기 쉽도록, 좀더 많은 메타기호를 추가했다. 반복`{}` 그리고 반복에 대한 횟수를 정할 수 있고, 1개 이상인 반복문뿐만 아니라 있을 수 있는(0 or 1) `[]`를 추가했다. 그리고 마지막으로 `구문도표`가 있는데 구문도표는 구문에 대한 형식정의를 할 수 있다. EBNF와 1:1로 매핑된다.

* 문맥자유문법: 문맥과 상관없이, 구문을 살펴 검사하는 방법
* 문맥의존문법: 문맥과 관계를 가지며 검사하는 방법
