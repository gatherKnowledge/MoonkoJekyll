StackFrame 임의의 함수에 선언된 메모리 공간(매번 함수마다 지정되는 범위가 다르다)
 함수, 지역변수를 사용 할 때 Stack이라는 메모리 구조를 사용하는데, 이 Stack의 메모리 공간에 겹치지 않고 차곡차곡 쌓이고 있다. 어떤 원리로 차곡차곡 쌓이고 있는 것일까?
그 것은 어디까지 봤을까 하는 누군가가 존재한다 ---> SP (REG)
쌓는 것은 어렵지 않은데 반환은? 얘는 어디로 돌아가야 될지 알 수 없다! -- ? (프레임포인터레지스터 == BP)
쉽게 생각해보면 SP의 백업 = FP/ 스택에 저장 돼 있는 부분을 지우는 것이 아니고 SP = BP ;를 이용해서 덮어쓰게 된다
호출에 호출을 하게 되면? FP에 대한 백업을 둬야 한다는 생각이 이어져야 한다. FP는 사실 하나의 레지스터가 아니라 메모리에 저장을 하고 있는 것이다! 헐? 얘 역시 STACK구조에 같이 집어 넣어 버린다. 다른 서브 프로시져를 호출 하기 전에

_STACK의 pop과 push를 디자인해보자_

실행의 이동의 문제?(프로그램의 흐름 제어는 어떻게 동작하는 것일까?)
 1. PC 다음에 실행할 명령어의 위치에 있다(x86계열에서는 IP라고 부른다)
 2. 프로그램카운터가 가르키는 주소의 명령어를 실행시킨다
 3. PC를 변경 시키면 다음 실행시키는 명령어를 변경 시킬 수 있다.
    - 순차적의 실행이면서 실행의 이동을 제공하게 된다.
> PC가 제어권이 바뀌게 되면 돌아갈 곳을 알아야 하는데 역시 LR(Link REG)에 저장하게 된다. 그리고 마찬가지로 SubCall이 늘어나게 된다면 함께 STACK에 저장하게 된다.

하나의 프로그램에서 둘 이상의 프로세스를 가져야 하는 상황 게임이 대표적이다. 예를 들어, 테트리스를 혼자하고 있다가 옆 사람이 같이 하게 되는 경우를 생각해보면 비슷한 상황이라고 할 수 있다.
두 개의 프로세스가 생성되려면 두 개의 프로세스 각 각의 C/D/S/H 영역이 필요하다. 만약 프로세스를 같은 자원으로 돌린다고 할 때, 그 중에 절대 둘이서 공유하기 힘든 부분은 무엇일까? 반대로 공유 할 수 있는 부분은 무엇일까?
C/D/H 영역은 공유 할 수 있고 흐름 제어가 들어가는 Stack은 공유 할 수 없다. 설명한대로 스택을 제외한 모든 영역을 공유하는 것을 쓰레드라고 부른다 그리고 반대로 모든 것을 공유하지 않고 모든 것을 생성한다 한다 이것은 프로세스라고 부른다

 다른 데이터 영역들을 공유하기 때문에 쓰레드는 코드 영역을 공유하기 때문에 전역변수/함수/힙에  대한 접근이 가능하다 반대로 프로세스 같은 경우에는 공유하는 것이 하나도 없다 때문에 공유하기 불편하다(IPC 모델을 이용해서 데이터를 공유해야 한다). 그렇다면 프로세스와 쓰레드를 생성했을 때의 단점은 무엇일까? 멀티 프로세스로 처리해야 하는 문제가 있고 쓰레드로 해결해야 되는 문제가 정해져 있다.

 사실 윈도우즈가 스케쥴링 해주는 것은 프로세스가 아닌 쓰레드였다. 프로세스의 상태정보는 사실 프로세스 안에 있던 것이 아니고 쓰레드에 있던 것 이었다. 하지만 우리는 두 가지 관점에서 모두 볼 수 있어야 한다. 왜?
`Blocked(IO상태가 됐을 때) - Running - Ready` 지금까지 우리가 만들었던 내용 자체가 하나의 메인 쓰레드라고 생각 할 수도 있기 때문이다. 그렇다면 결론을 내려본다면 쓰레드가 돌아갈 수 있는 환경을 제공해주는 것이 프로세스이고 그 환경에서 흐름을 제어하는 것이 쓰레드이다.

**커널 레벨 쓰레드vs유저 레벨 쓰레드** 중요한 내용
 일반적으로 얘기하는 쓰레드는 OS에서 제공하는 형태드의 쓰레드인데 이를 제공하지 않는 OS가 있다면 개발자들은 이를 라이브러리 형태로 제공하는 형태로 만들어 사용해야 한다. 이를 `유저레벨`쓰레드라고 부른다. 반대로OS의 API의 제공을 받아 사용하는 쓰레드 `커널 레벨` 쓰레드라고 한다.
`커널 레벨`쓰레드에서는 Task를 할당 받는 시간이 모두 동등하다. 하지만 유저 레벨 쓰레드로 생성 된 쓰레드의 경우 처리되는 과정이 조금 다르고 때문에 성능 측면에서도 차이가 보이는데, 예를 들어 Thread가 io상태에 빠졌을 때 Process A, B가 있고 쓰레드 AB/C 할당받는 시간,블러킹 상태등의 불합리한 점이 있음 하지만 `유저레벨` 쓰레드의 경우 속도면에서 빠르다.

커널모드/유저모드 상태
둘 중 하나이다. 항상. OS + App 2G/2G 앱과 OS
실제로 실행파일은 그렇게 크지 않다! 코드를 실행하기 위한 환경을 구성하는데 많은 리소스를 차지한다.
두 가지 모드를 만든다. 메모리 공간 어디든지 접근 가능한데 이렇게 되면 사용자가 실수로라도 Windows가 사용하고 있는 메모리 영역을 침범 할 수 있다. 이렇게 되면 예기치 못한 오류가 생길 수 있는데 이를 방지하기 위해 만들어진 것이 kernel모드 와 User모드이다.
`커널 레벨` 쓰레드의 경우, 관리하는 대상이 쓰레드이기 때문에 여러번의 Context Switching (커널모드로 접근해서) 기능은 많고 좋지만 성능면에서 떨어질 수 밖에 없다. 그리고 안정적이다.

쓰레드의 생성/생성 가능한 쓰레드 개수는 최대한 허용 할 수 있을 때까지 허용한다. 스택의 크기가 10MB일 때 2GB를 할당 받았다고하면 200개가 되겠다.

쓰레드 종료시의 Return을 이용하면 좋은 경우 거의 대부분의 경우(99%)
ExitThread가 유용한 경우(1%) 쓰레드 역시 쓰레드의 메인함수가 종료되면..
